package main

import (
	"fmt"
	"io"
	"log"
	"math"
	"os"

	"github.com/gabriel-vasile/mimetype"
)

// Compression ratio heuristics based on file type
var compressionRatios = map[string]float64{
	"text":  0.3,  // ~70% reduction
	"csv":   0.4,  // ~60% reduction
	"xml":   0.5,  // ~50% reduction
	"json":  0.5,  // ~50% reduction
	"exe":   0.7,  // ~30% reduction
	"zip":   0.95, // ~5% reduction (already compressed)
	"jpg":   0.98, // ~2% reduction
	"png":   0.98, // ~2% reduction
	"mp3":   0.99, // ~1% reduction
	"mp4":   0.99, // ~1% reduction
	"other": 0.6,  // Default assumption
}

// estimateEntropy calculates the entropy of a file using a small sample
func estimateEntropy(filePath string, sampleSize int) float64 {
	file, err := os.Open(filePath)
	if err != nil {
		log.Fatalf("Failed to open file: %v", err)
	}
	defer file.Close()

	data, err := io.ReadAll(file)
	if err != nil {
		log.Fatalf("Failed to read file: %v", err)
	}

	if len(data) == 0 {
		return 0 // Empty file
	}

	sample := data[:min(len(data), sampleSize)]
	freq := make(map[byte]float64)
	for _, b := range sample {
		freq[b]++
	}

	entropy := 0.0
	for _, count := range freq {
		p := float64(count) / float64(len(sample))
		entropy -= p * math.Log2(p)
	}

	return entropy / 8 // Normalize (1 = max entropy, 0 = no entropy)
}

// estimateCompression estimates the compressed file size based on file type and entropy
func estimateCompression(filePath string) map[string]interface{} {
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		log.Fatalf("Failed to get file info: %v", err)
	}
	fileSize := fileInfo.Size()

	mimeType, err := mimetype.DetectFile(filePath)
	if err != nil {
		log.Fatalf("Failed to detect MIME type: %v", err)
	}

	// Map MIME type to compression ratio
	compressionRatio := 0.0
	switch {
	case mimeType.Is("text/plain") || mimeType.Is("text/csv"):
		compressionRatio = compressionRatios["text"]
	case mimeType.Is("application/xml"):
		compressionRatio = compressionRatios["xml"]
	case mimeType.Is("application/json"):
		compressionRatio = compressionRatios["json"]
	case mimeType.Is("application/zip"):
		compressionRatio = compressionRatios["zip"]
	case mimeType.Is("image/jpeg"):
		compressionRatio = compressionRatios["jpg"]
	case mimeType.Is("image/png"):
		compressionRatio = compressionRatios["png"]
	case mimeType.Is("audio/mpeg"):
		compressionRatio = compressionRatios["mp3"]
	case mimeType.Is("video/mp4"):
		compressionRatio = compressionRatios["mp4"]
	case mimeType.Is("application/x-msdownload"): // EXE files
		compressionRatio = compressionRatios["exe"]
	default:
		compressionRatio = compressionRatios["other"]
	}

	// Adjust based on entropy
	entropy := estimateEntropy(filePath, 1024)
	entropyFactor := (1-entropy)*0.5 + 0.5 // Scale between 0.5 to 1
	adjustedRatio := compressionRatio * entropyFactor

	// Estimated compressed size
	estimatedSize := int64(float64(fileSize) * adjustedRatio)

	return map[string]interface{}{
		"file":                      filePath,
		"original_size":             fileSize,
		"estimated_compressed_size": estimatedSize,
		"compression_ratio":         adjustedRatio,
	}
}

// min returns the smaller of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	// Example usage
	filePath := "example.txt" // Change to any file
	result := estimateCompression(filePath)
	fmt.Printf("%+v\n", result)
}
